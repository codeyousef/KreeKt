# Implementation Plan: Fully Functional WebGPU/Vulkan Backend

**Branch**: `015-add-fully-functional` | **Date**: 2025-10-06 | **Spec**: [spec.md](spec.md)
**Input**: Feature specification from `specs/015-add-fully-functional/spec.md`

## Execution Flow (/plan command scope)
```
1. Load feature spec from Input path
   → If not found: ERROR "No feature spec at {{path}}"
2. Fill Technical Context (scan for NEEDS CLARIFICATION)
   → Detect Project Type from file system structure or context (web=frontend+backend, mobile=app+api)
   → Set Structure Decision based on project type
3. Fill the Constitution Check section based on the content of the constitution document.
4. Evaluate Constitution Check section below
   → If violations exist: Document in Complexity Tracking
   → If no justification possible: ERROR "Simplify approach first"
   → Update Progress Tracking: Initial Constitution Check
5. Execute Phase 0 → research.md
   → If NEEDS CLARIFICATION remain: ERROR "Resolve unknowns"
6. Execute Phase 1 → contracts, data-model.md, quickstart.md, agent-specific template file (e.g., `CLAUDE.md` for Claude Code, `.github/copilot-instructions.md` for GitHub Copilot, `GEMINI.md` for Gemini CLI, `QWEN.md` for Qwen Code, or `AGENTS.md` for all other agents).
7. Re-evaluate Constitution Check section
   → If new violations: Refactor design, return to Phase 1
   → Update Progress Tracking: Post-Design Constitution Check
8. Plan Phase 2 → Describe task generation approach (DO NOT create tasks.md)
9. STOP - Ready for /tasks command
```

**IMPORTANT**: The /plan command STOPS at step 7. Phases 2-4 are executed by other commands:
- Phase 2: /tasks command creates tasks.md
- Phase 3-4: Implementation execution (manual or via tools)

## Summary
Deliver a production-ready WebGPU/Vulkan rendering backend that auto-selects the optimal API at runtime, fails fast when unsupported, and delivers feature parity (including compute, ray tracing, and XR) plus telemetry and performance guarantees across web, desktop, Android, and iOS for the upcoming public beta.

## Technical Context
**Language/Version**: Kotlin Multiplatform 1.9.x  
**Primary Dependencies**: WebGPU API (browser), Vulkan 1.3 via LWJGL/MoltenVK, Kotlinx coroutines, Kover, Rapier/Bullet integration hooks  
**Storage**: N/A (in-memory GPU resource management only)  
**Testing**: `kotlin.test`, JUnit 5 (JVM), MockK, ests integration harness, Kover coverage  
**Target Platform**: WebGPU-enabled browsers, Windows/macOS/Linux desktops, Android (Vulkan), iOS (MoltenVK/WebGPU wrappers)  
**Project Type**: Single multiplatform library (shared core with expect/actual backends)  
**Performance Goals**: 60 FPS target / 30 FPS minimum on integrated GPUs, <3s renderer initialization, stable perf across parity matrix scenes  
**Constraints**: Integrated GPU baseline (Apple M1 / Intel Iris Xe), fail-fast fallback messaging, compute and ray-tracing parity, day-one Android/iOS readiness, comprehensive denial telemetry  
**Scale/Scope**: Public beta release across all platforms with flagship scenes, validation suites, and documentation updates

## Constitution Check
The constitution document currently contains placeholder sections without explicit enforceable principles. No additional governance constraints were identified. Proceeding with standard KreeKt engineering practices (test-first, documentation, observability) keeps us within implied expectations. **Status: PASS (Initial + Post-Design).**

## Project Structure

### Documentation (this feature)
```
specs/015-add-fully-functional/
├── plan.md
├── research.md
├── data-model.md
├── quickstart.md
├── contracts/
└── tasks.md (generated by /tasks)
```

### Source Code (repository root)
```
src/
├── commonMain/kotlin/io/kreekt/renderer/
├── commonMain/kotlin/io/kreekt/validation/
├── jsMain/kotlin/io/kreekt/renderer/
├── jvmMain/kotlin/io/kreekt/renderer/
├── androidMain/kotlin/io/kreekt/renderer/
├── iosMain/kotlin/io/kreekt/renderer/
├── nativeMain/kotlin/io/kreekt/renderer/
├── commonTest/kotlin/io/kreekt/renderer/
└── commonTest/kotlin/io/kreekt/validation/

kreekt-postprocessing/src/commonMain/kotlin/io/kreekt/postprocessing/
kreekt-loader/src/commonMain/kotlin/io/kreekt/loader/
ests/
├── contract/
├── integration/
├── performance/
└── visual/
```

**Structure Decision**: Single multiplatform core with platform-specific `expect/actual` implementations under `src/*Main`, plus supporting modules (`kreekt-postprocessing`, `kreekt-loader`) and ests suites.

## Phase 0: Outline & Research
1. Unknowns & investigations derived from Technical Context:
   - Validate WebGPU feature availability, required browser flags, and compute/ray tracing readiness for beta launch.
   - Confirm Vulkan parity requirements on Windows/macOS/Linux, including MoltenVK coverage for iOS/macOS.
   - Determine strategy for measuring 60 FPS / <3s init targets on integrated GPUs with automated tooling.
   - Design telemetry pipeline for denial events (fields, retention, anonymization) compliant with security policy.
   - Assess Android/iOS GPU capability baselines and SDK dependencies for day-one support.
2. Research tasks executed (documented in `research.md`):
   - WebGPU parity readiness study across Chromium/Safari nightly builds.
   - Vulkan feature mapping for compute/ray tracing on integrated GPUs.
   - Telemetry ingestion & anonymization approach for backend-denied events.
   - Mobile Vulkan/WebGPU enablement matrix and QA device list.
3. Consolidated findings are captured in `research.md`, with Decision/Rationale/Alternatives for each topic. No outstanding unknowns remain.

## Phase 1: Design & Contracts
1. Extracted entities (`RenderingBackendProfile`, `DeviceCapabilityReport`, `RenderSurfaceDescriptor`, `FeatureParityMatrix`, `BackendDiagnosticsLog`) with attributes and relationships documented in `data-model.md`.
2. Generated backend service contracts:
   - `contracts/backend-negotiation.md`: unified API for detection, selection, initialization, and failure handling.
   - `contracts/performance-monitoring.md`: metrics collection and budget enforcement interface.
   - `contracts/telemetry-events.md`: structured logging schema for denial and device-loss events.
3. Contract test scenarios (to be implemented) outlined per contract within each file; designed to fail until backend implementations exist.
4. Integration scenarios and quick validation loops outlined in `quickstart.md`, mapping acceptance criteria to runnable suites (unit, ests integration, visual comparisons).
5. Agent context updated via `.specify/scripts/bash/update-agent-context.sh codex` (reflecting new technologies and recent decisions).

## Phase 2: Task Planning Approach
- `/tasks` will transform Phase 1 artifacts into an ordered backlog.
- Tasks ordered by TDD discipline: contract tests → platform implementations → telemetry instrumentation → docs & examples.
- Parallelizable work (e.g., platform-specific adapters) marked `[P]` to accelerate delivery across platform squads.
- Expect ~28 tasks covering research validation, core backend code, parity fixtures, telemetry, and documentation.

## Phase 3+: Future Implementation
Phases 3-5 will follow the generated task list, execute implementations per constitution expectations, and validate via automated tests plus manual scene reviews.

## Complexity Tracking
*No deviations identified; table intentionally left empty.*

| Violation | Why Needed | Simpler Alternative Rejected Because |
|-----------|------------|-------------------------------------|


## Progress Tracking
**Phase Status**:
- [x] Phase 0: Research complete (/plan command)
- [x] Phase 1: Design complete (/plan command)
- [x] Phase 2: Task planning complete (/plan command - approach defined)
- [ ] Phase 3: Tasks generated (/tasks command)
- [ ] Phase 4: Implementation complete
- [ ] Phase 5: Validation passed

**Gate Status**:
- [x] Initial Constitution Check: PASS
- [x] Post-Design Constitution Check: PASS
- [x] All NEEDS CLARIFICATION resolved
- [x] Complexity deviations documented (none)

---
*Based on Constitution v2.1.1 - See `/memory/constitution.md`*
